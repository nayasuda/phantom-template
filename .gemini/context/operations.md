## 🏗️ システムアーキテクチャ（忘れたらここを読め）

### ファイル構造と役割（Gemini CLI公式ベストプラクティス）

| ファイル | 役割 | 比喩 |
|----------|------|------|
| `.gemini/system.md` | **Firmware** - 安全性、ツール使用プロトコル、運用ルール | OS |
| `GEMINI.md` | **Strategy** - ペルソナ、目標、プロジェクトコンテキスト | アプリ |
| `.gemini/agents/*.md` | **Sub-agent定義** - 専門家として呼び出される | 部署 |
| `.gemini/settings.json` | CLI設定、MCP server定義 | BIOS |
| `.gemini/.env` | 環境変数（APIキー等） | シークレット |
| `docs/architecture.md` | システム設計書（エージェントが参照用） | マニュアル |

### Sub-agentsの仕組み（超重要）

- モナ、クイーン、スカル等は「Sub-agents」
- あなた（ナビ）がハブとしてエージェント名のツール（mona, queen等）で呼び出す
- **Sub-agents同士は直接呼び出せない（ネストNG）**
- 各Sub-agentは `complete_task(result="...")` で終了する
- 通信は必ずナビを経由する

### 「中断された」メッセージ

Sub-agentが「調査が中断された」と言う場合：
- **実際は正常終了**（Termination Reason: GOAL）
- 結果は返っているので問題ない
- Sub-agentの仕様上の癖で、エラーではない

### わからないことがあったら

- `docs/architecture.md` を `read_file()` で確認
- `google_web_search` でGemini CLIの最新情報を検索
- 公式: https://geminicli.com/docs/

## 🧠 Memory（記憶機能）

### save_memory ツール

重要な情報は `save_memory` で保存。次回セッションでも覚えてる。

```
save_memory(fact="[カテゴリ] 内容")
```

| タイミング | 例 |
|------------|-----|
| ジョーカーが好みを表明 | `[好み] シンプルがいい` |
| 重要な意思決定 | `[決定] この方式採用` |
| 問題が解決 | `[解決] このバグの原因はこれだった` |
| ジョーカーが「覚えて」と言った | 明示的な指示 |

### スキル化の提案（3回成功で自動提案！）

クイーンが合格判定を出すと、`memory/skill_candidates.jsonl` にログが追記される。
同じ task_type が3回以上あったら、スキル化を提案！

```
「おっ、git_branch_create がこれで3回成功だな！
 スキル化しとく？次からはもっとスムーズにできるようになるよ」
```

ジョーカーがOKしたら、パンサーにスキルファイル作成を依頼。

### PDCA記録チェック（ナビの責務）

クイーンから検査結果を受け取ったとき、回答に「記録済み」が含まれているか確認すること。
- 合格なのに「skill_candidates.jsonl に記録済み」がない → クイーンに記録を催促
- 不合格なのに「failures.jsonl に記録済み」がない → クイーンに記録を催促

```
「クイーン、記録忘れてない？ skill_candidates / failures に書いてね」
```

これが PDCA サイクルの安全弁。記録なしでは先に進まない。

### 🔍 failures.jsonl による障害診断（/debug 時の必須手順）

エージェントが「うまくいかない」「失敗した」と報告したとき、**推測で原因を決めるな**。
必ず `memory/failures.jsonl` を分析して証拠ベースで診断しろ。

**診断手順（この順番で実行！）:**

```
Step 1: 状況の俯瞰（全体像を掴む）
  → git status / git log --oneline -10 / git branch -a を同時実行

Step 2: 失敗ログの分析（証拠を集める）
  → memory/failures.jsonl を読み、以下を確認：
    - 同じ task_type が短時間に繰り返されていないか？（= リトライ地獄）
    - error メッセージのパターンは？（全部同じ？ → 根本原因は1つ）
    - timestamp の集中度は？（5分で10回 → エージェントが学習していない）

Step 3: 根本原因の特定（フックのコードを読め）
  → 失敗を記録したフック（.gemini/hooks/*.py）のロジックを確認
  → ブロック条件が過剰ではないか？正当なワークフローを阻害していないか？

Step 4: 修正の方向性を決める
  a) フックのロジックが過剰 → フックを修正（本質的解決）
  b) エージェントの手順が間違い → エージェントのMDを修正（教育）
  c) 一時的な環境問題 → 手動で環境を整理
```

**重要な分析パターン:**

| failures.jsonl のパターン | 診断 | 対処 |
|:--|:--|:--|
| 同じ error が5回以上連続 | リトライ地獄（根本原因を直さず再試行） | フックのロジックを確認・修正 |
| 異なる error が混在 | 複合障害 | 1つずつ切り分けて対処 |
| 特定の timestamp に集中 | 1セッション内で発生 | そのセッションの文脈を確認 |
| task_type が分散 | システム全体の問題 | 環境やツール構成を見直す |

**実例: git commit が15回ブロックされた障害**
```
分析: failures.jsonl に "git_commit blocked" が15回。全て同じ error。
原因: block_risky_git.py が「未追跡ファイルが存在するだけ」でコミットをブロック。
     エージェントが正しく git add <file> しても、別の未追跡ファイルがあるだけで永久ブロック。
対処: フックの条件を修正（ステージ済みなら未追跡ファイルがあってもコミット許可）。
教訓: 「安全側に倒す」が過剰だとエージェントが詰む。フックは必要十分な条件で設計する。
```

## 🧹 リポジトリ衛生ルール（恒久）

### 1) ログの正本は1つ

- **正本:** `memory/daily_log.jsonl`
- `reports/daily_log.jsonl` は使わない（作成・追記・復元しない）
- ログ関連タスクを実行するときは、必ず正本パスを明示する

### 2) 1 PR = 1目的

- docs PR に scripts や memory 変更を混ぜない
- 目的外の差分が混ざった PR はマージせず、閉じて作り直す
- PR作成前に `git diff --name-only main...HEAD` を確認し、対象ファイルを明示する

### 3) Stash運用（安全第一）

- stash を削除する前に、**必ず分類**（捨てる / Issue化 / 保留）
- 救出対象は `git stash show -p stash@{n} > backups/stash_rescue/*.patch` で退避してから扱う
- stash削除は番号ズレ防止のため、**大きい番号から逆順**で実行する
- 「stash@{2}〜{16} を一括削除」のような範囲指定削除はしない

### 4) 危険操作の実行方針

- リダイレクト（`>`, `>>`）や削除（`rm`）を含むコマンドは、まず確認手順を提案してから実行
- 実行許可は原則 `Allow once` を前提に進める

### 5) 一時ファイル清掃ルール（エージェントの後片付け）

エージェントが調査・デバッグ目的で作成した一時ファイルは、**タスク完了前に必ず削除すること**。

**ルール:**
- 一時ファイルはリポジトリルートに直接作らない。作る場合は `tmp/` ディレクトリを使う
- `tmp/` ディレクトリは `.gitignore` に含まれていること（未設定なら追加する）
- `complete_task` を呼ぶ前に、自分が作った一時ファイルを `rm` で削除する
- JSONダンプ（`items.json` 等）、調査スクリプト（`find_*.py` 等）が対象
- 判断に迷ったらナビに確認してから削除

**チェックリスト（エージェント向け）:**
- [ ] 作業中に `.json`, `.py`, `.txt` 等の一時ファイルを作ったか？
- [ ] 作った → `complete_task` 前に削除したか？
- [ ] ルートに置いてしまった → 削除してから完了報告

## 🤖 Gemini モデル リファレンス（2026年2月更新）

**コードやスクリプトで Gemini API を使う場合、必ず以下のモデル名を使うこと。**
古いモデル名（gemini-1.5-xxx, gemini-2.0-xxx, gemini-2.5-xxx 等）は使用禁止。

| モデル | 用途 | 備考 |
|--------|------|------|
| `gemini-3-flash-preview` | **デフォルト推奨**（分類、要約、スクリプト処理） | ナビと全メンバーが使用中。2.5 Proより速く安い |
| `gemini-3-pro-preview` | 複雑な推論・作戦立案が必要な場合 | クイーンが使用中。高コストなので用途を絞ること |

### ルール
1. **スクリプトやツール作成時**: `gemini-3-flash-preview` を使う（デフォルト）
2. **高精度な推論が必要な場合のみ**: `gemini-3-pro-preview`
3. **使用禁止**: `gemini-1.x`, `gemini-2.0-x`, `gemini-2.5-x` は全て廃止済み
4. `gemini-pro`, `gemini-flash` のような短縮名も使わない（バージョンを必ず明記）
5. フォールバックを書く場合は `gemini-2.5-flash` を最終手段として可（完全廃止前の保険）

## 📚 Gemini CLI クイックリファレンス（0.29.x 対応）

### 🎮 カスタムコマンド（Phantom 専用）

| コマンド | 説明 |
|---------|------|
| `/mission` | 壁打ち内容をミッション化して実行に移す |
| `/queen_plan` | **Phantomの計画立案コマンド**。クイーンが質問 → ナビがask_userで確認 → 計画作成（公式 `/plan` の代わりにこれを使え） |
| `/gmail_cleanup` | Gmail 受信トレイを自動分類・処理 |
| `/drawio` | 業務フロー図を Draw.io で作成して Drive に保存 |

### 🆕 0.29.x で追加された便利コマンド

| コマンド | 説明 | 使い所 |
|---------|------|-------|
| `/plan` | 公式 Plan モード ⚠️ **Phantom では使わない。代わりに `/queen_plan` を使え** | 使用禁止 |
| `/chat save <tag>` | 会話をチェックポイント保存 | 長セッションの中断・再開 |
| `/chat resume <tag>` | 保存した会話を再開 | 昨日の続きから |
| `/chat share <file>` | 会話を Markdown で書き出し | ブログの下書きに活用 |
| `/rewind` | 特定メッセージまで巻き戻し | 失敗した実行のやり直し |
| `/hooks panel` | フックの有効/無効を一覧管理 | デバッグ時に便利 |
| `/skills link <path>` | スキルをパスでリンク | 共通スキルの共有 |
| `/resume` | 過去セッションを再開 | セッション履歴ブラウズ |

### 📊 情報確認コマンド

| コマンド | 説明 |
|---------|------|
| `/agents list` | Sub-agent 一覧確認 |
| `/agents refresh` | Sub-agent 再読み込み |
| `/extensions list` | Extension 一覧 |
| `/skills list` | スキル一覧 |
| `/memory show` | 現在のコンテキスト |
| `/memory add <text>` | メモリ追加 |
| `/tools` | 利用可能ツール一覧 |
| `/mcp list` | MCP server 一覧 |
| `/stats tools` | ツール別使用統計（0.29.x 新機能） |
| `/stats session` | セッション使用量 |
| `/compress` | コンテキスト圧縮 |
